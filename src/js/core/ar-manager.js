/**
 * AR Manager - Gerencia funcionalidades de Realidade Aumentada
 * Controla detec√ß√£o de marcadores, carregamento de modelos 3D e intera√ß√µes AR
 */

class ARManager {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.isARReady = false;
        this.activeMarkers = new Set();
        this.loadedModels = new Map();
        
        this.init();
    }
    
    init() {
        console.log('üéØ ARManager: Inicializando...');
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupAR());
        } else {
            this.setupAR();
        }
    }
    
    setupAR() {
        // Get A-Frame scene
        this.scene = document.querySelector('a-scene');
        this.camera = document.querySelector('#camera');
        
        if (!this.scene) {
            console.error('‚ùå ARManager: A-Frame scene n√£o encontrada');
            return;
        }
        
        // Setup scene event listeners
        this.setupSceneEvents();
        
        // Setup marker events
        this.setupMarkerEvents();
        
        // Check camera permissions
        this.checkCameraPermissions();
        
        console.log('‚úÖ ARManager: Configurado com sucesso');
    }
    
    setupSceneEvents() {
        // Scene loaded
        this.scene.addEventListener('loaded', () => {
            console.log('üì± ARManager: Cena A-Frame carregada');
            this.onSceneLoaded();
        });
        
        // AR ready
        this.scene.addEventListener('arjs-ready', () => {
            console.log('üéØ ARManager: AR.js pronto');
            this.isARReady = true;
            this.hideLoadingScreen();
        });
        
        // Camera ready
        this.scene.addEventListener('camera-init', () => {
            console.log('üìπ ARManager: C√¢mera inicializada');
        });
    }
    
    setupMarkerEvents() {
        // Find all markers
        const markers = document.querySelectorAll('a-marker');
        
        markers.forEach(marker => {
            const markerId = marker.id || marker.getAttribute('preset');
            
            // Marker found
            marker.addEventListener('markerFound', () => {
                console.log(`üéØ Marcador encontrado: ${markerId}`);
                this.onMarkerFound(markerId, marker);
                this.activeMarkers.add(markerId);
            });
            
            // Marker lost
            marker.addEventListener('markerLost', () => {
                console.log(`üì± Marcador perdido: ${markerId}`);
                this.onMarkerLost(markerId, marker);
                this.activeMarkers.delete(markerId);
            });
        });
    }
    
    onSceneLoaded() {
        // Hide loading screen after a short delay
        setTimeout(() => {
            this.hideLoadingScreen();
        }, 2000);
    }
    
    onMarkerFound(markerId, markerElement) {
        // Update debug info
        this.updateDebugInfo(`Marcador ${markerId} detectado!`, 'success');
        
        // Add visual feedback
        this.addMarkerFeedback(markerElement);
        
        // Trigger custom event
        document.dispatchEvent(new CustomEvent('marker-detected', {
            detail: { markerId, markerElement }
        }));
    }
    
    onMarkerLost(markerId, markerElement) {
        // Update debug info
        this.updateDebugInfo(`Procurando marcadores...`, 'info');
        
        // Remove visual feedback
        this.removeMarkerFeedback(markerElement);
        
        // Trigger custom event
        document.dispatchEvent(new CustomEvent('marker-lost', {
            detail: { markerId, markerElement }
        }));
    }
    
    addMarkerFeedback(markerElement) {
        // Add glow effect or animation to indicate marker detection
        const objects = markerElement.querySelectorAll('a-box, a-sphere, a-cylinder, a-gltf-model');
        objects.forEach(obj => {
            obj.setAttribute('animation__scale', {
                property: 'scale',
                from: '0.8 0.8 0.8',
                to: '1 1 1',
                dur: 500,
                easing: 'easeOutBounce'
            });
        });
    }
    
    removeMarkerFeedback(markerElement) {
        // Remove feedback animations
        const objects = markerElement.querySelectorAll('a-box, a-sphere, a-cylinder, a-gltf-model');
        objects.forEach(obj => {
            obj.removeAttribute('animation__scale');
        });
    }
    
    updateDebugInfo(message, type = 'info') {
        const debugElement = document.getElementById('debug-info');
        if (!debugElement) return;
        
        const emoji = {
            'success': '‚úÖ',
            'error': '‚ùå',
            'info': 'üîç',
            'warning': '‚ö†Ô∏è'
        };
        
        const lastP = debugElement.querySelector('p:last-child');
        if (lastP) {
            lastP.innerHTML = `${emoji[type]} ${message}`;
        }
    }
    
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
    }
    
    checkCameraPermissions() {
        console.log('üì∑ ARManager: Verificando permiss√µes de c√¢mera...');
        
        // Check if mediaDevices is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.warn('‚ö†Ô∏è ARManager: getUserMedia n√£o suportado');
            this.showCameraButton();
            return;
        }
        
        // Configure camera constraints for wide-angle camera (avoid telephoto)
        const cameraConstraints = {
            video: {
                facingMode: 'environment', // Use back camera
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                // Force wide-angle camera selection
                advanced: [{
                    focusMode: 'continuous',
                    zoom: { ideal: 1.0, max: 1.0 } // Prevent zoom/telephoto
                }]
            }
        };
        
        // Try to get wide-angle camera first
        navigator.mediaDevices.getUserMedia(cameraConstraints)
        .then(stream => {
            console.log('‚úÖ ARManager: Permiss√£o de c√¢mera concedida (grande-angular)');
            
            // Check camera capabilities
            const videoTrack = stream.getVideoTracks()[0];
            if (videoTrack) {
                const capabilities = videoTrack.getCapabilities();
                console.log('üì∏ ARManager: Capacidades da c√¢mera:', {
                    focusMode: capabilities.focusMode,
                    zoom: capabilities.zoom,
                    width: capabilities.width,
                    height: capabilities.height
                });
                
                // Apply optimal settings for AR
                const constraints = {
                    focusMode: 'continuous',
                    zoom: 1.0 // Force minimum zoom
                };
                
                videoTrack.applyConstraints(constraints)
                .then(() => {
                    console.log('üéØ ARManager: Configura√ß√µes de c√¢mera aplicadas para AR');
                })
                .catch(err => {
                    console.warn('‚ö†Ô∏è ARManager: N√£o foi poss√≠vel aplicar configura√ß√µes:', err);
                });
            }
            
            // Stop the stream as we just needed to check permissions
            stream.getTracks().forEach(track => {
                track.stop();
                console.log(`üìπ ARManager: Track ${track.kind} parado`);
            });
            
            // Hide loading screen after camera check
            setTimeout(() => {
                this.hideLoadingScreen();
            }, 1000);
        })
        .catch(error => {
            console.warn('‚ö†Ô∏è ARManager: Erro com c√¢mera grande-angular, tentando c√¢mera padr√£o...');
            
            // Fallback to simpler constraints
            const fallbackConstraints = {
                video: {
                    facingMode: 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };
            
            navigator.mediaDevices.getUserMedia(fallbackConstraints)
            .then(stream => {
                console.log('‚úÖ ARManager: Permiss√£o de c√¢mera concedida (fallback)');
                stream.getTracks().forEach(track => {
                    track.stop();
                    console.log(`üìπ ARManager: Track ${track.kind} parado`);
                });
                
                setTimeout(() => {
                    this.hideLoadingScreen();
                }, 1000);
            })
            .catch(fallbackError => {
                console.warn('‚ö†Ô∏è ARManager: Erro ao acessar c√¢mera:', fallbackError.name, fallbackError.message);
                this.handleCameraError(fallbackError);
            });
        });
    }
    
    handleCameraError(error) {
        if (error.name === 'NotAllowedError') {
            console.log('üö´ ARManager: Permiss√£o de c√¢mera negada pelo usu√°rio');
            this.showCameraButton();
        } else if (error.name === 'NotFoundError') {
            console.log('üì∑ ARManager: Nenhuma c√¢mera encontrada');
            this.showCameraButton();
        } else {
            console.log('‚ö†Ô∏è ARManager: Erro desconhecido de c√¢mera');
            this.showCameraButton();
        }
    }
    
    showCameraButton() {
        const cameraBtn = document.getElementById('enable-camera');
        if (cameraBtn) {
            cameraBtn.style.display = 'flex';
            cameraBtn.addEventListener('click', () => {
                this.requestCameraPermission();
            });
        }
    }
    
    requestCameraPermission() {
        console.log('üì∑ ARManager: Solicitando permiss√£o de c√¢mera...');
        
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // Enhanced constraints for wide-angle camera
            const cameraConstraints = {
                video: {
                    facingMode: 'environment', // Prefer back camera
                    width: { ideal: 1280, max: 1920 },
                    height: { ideal: 720, max: 1080 },
                    // Try to avoid telephoto camera
                    advanced: [{
                        focusMode: 'continuous',
                        zoom: { ideal: 1.0, max: 1.0 },
                        torch: false
                    }]
                }
            };
            
            navigator.mediaDevices.getUserMedia(cameraConstraints)
            .then(stream => {
                console.log('‚úÖ ARManager: C√¢mera ativada pelo usu√°rio (grande-angular)');
                
                // Log camera info
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    console.log('üì∏ ARManager: Configura√ß√µes da c√¢mera:', {
                        width: settings.width,
                        height: settings.height,
                        facingMode: settings.facingMode,
                        deviceId: settings.deviceId
                    });
                    
                    // Try to ensure minimum zoom
                    videoTrack.applyConstraints({
                        advanced: [{ zoom: 1.0 }]
                    }).catch(err => {
                        console.log('üì∑ ARManager: Zoom n√£o suportado ou j√° no m√≠nimo');
                    });
                }
                
                stream.getTracks().forEach(track => {
                    track.stop();
                    console.log(`üìπ ARManager: Track ${track.kind} parado ap√≥s ativa√ß√£o`);
                });
                
                // Hide camera button
                const cameraBtn = document.getElementById('enable-camera');
                if (cameraBtn) {
                    cameraBtn.style.display = 'none';
                }
                
                // Show success message
                this.updateDebugInfo('C√¢mera grande-angular ativada! Recarregando...', 'success');
                
                // Reload the page to initialize AR properly
                setTimeout(() => {
                    location.reload();
                }, 1500);
            })
            .catch(error => {
                console.error('‚ùå ARManager: Erro ao ativar c√¢mera:', error.name, error.message);
                
                if (error.name === 'OverconstrainedError') {
                    console.log('üîÑ ARManager: Tentando c√¢mera com configura√ß√µes simplificadas...');
                    this.tryFallbackCamera();
                    return;
                }
                
                let message = 'Erro ao ativar c√¢mera';
                if (error.name === 'NotAllowedError') {
                    message = 'Permiss√£o de c√¢mera negada';
                } else if (error.name === 'NotFoundError') {
                    message = 'Nenhuma c√¢mera encontrada';
                }
                
                this.updateDebugInfo(message, 'error');
                alert(`${message}. Para usar o jogo AR, √© necess√°rio permitir o acesso √† c√¢mera.`);
            });
        } else {
            alert('Seu navegador n√£o suporta acesso √† c√¢mera.');
        }
    }
    
    tryFallbackCamera() {
        console.log('üîÑ ARManager: Tentando c√¢mera com configura√ß√µes simplificadas...');
        
        const fallbackConstraints = {
            video: {
                facingMode: 'environment',
                width: { ideal: 640 },
                height: { ideal: 480 }
            }
        };
        
        navigator.mediaDevices.getUserMedia(fallbackConstraints)
        .then(stream => {
            console.log('‚úÖ ARManager: C√¢mera fallback ativada');
            stream.getTracks().forEach(track => {
                track.stop();
                console.log(`üìπ ARManager: Track ${track.kind} parado`);
            });
            
            this.updateDebugInfo('C√¢mera ativada! Recarregando...', 'success');
            setTimeout(() => location.reload(), 1500);
        })
        .catch(error => {
            console.error('‚ùå ARManager: Falha no fallback da c√¢mera:', error);
            this.updateDebugInfo('Erro ao ativar c√¢mera', 'error');
            alert('N√£o foi poss√≠vel ativar a c√¢mera. Verifique as permiss√µes.');
        });
    }
    
    // Utility methods
    getActiveMarkers() {
        return Array.from(this.activeMarkers);
    }
    
    isMarkerActive(markerId) {
        return this.activeMarkers.has(markerId);
    }
    
    // Performance monitoring
    getPerformanceInfo() {
        const scene = this.scene;
        if (!scene || !scene.renderer) return null;
        
        const renderer = scene.renderer;
        return {
            fps: Math.round(1000 / scene.time),
            geometries: renderer.info.memory.geometries,
            textures: renderer.info.memory.textures,
            drawCalls: renderer.info.render.calls
        };
    }
}

// Initialize AR Manager when script loads
let arManager;

// Wait for page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        arManager = new ARManager();
    });
} else {
    arManager = new ARManager();
}

// Export for use in other modules
window.ARManager = ARManager;
window.arManager = arManager;